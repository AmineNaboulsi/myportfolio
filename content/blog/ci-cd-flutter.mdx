---
title: "CI/CD Pipeline for Mobile Apps with Flutter to Google Play Store"
description: "Learn how to set up a complete CI/CD pipeline for Flutter mobile applications using Gitlab, automated testing, and deployment to App Store and Play Store."
date: 2026-01-15
readTime: "15 min read"
category: "DevOps"
tags: ["Flutter", "CI/CD", "fastlane", "Mobile", "DevOps", "Automation"]
image: "/blog/cicd-flutter.png"
featured: true
---

# Setup Fastlane for Flutter

First we need to install fastlane on our machine, This action required ruby to be installed on your machine.
Well, I'm not going to cover how to install ruby on your machine, but you can find a guide [here](https://www.ruby-lang.org/en/documentation/installation/).
The fastlane this the one that will be used to communicate with the Google Play Store Based on a service account.
See dox [here](https://docs.fastlane.tools/getting-started/ios/setup/#installing-fastlane).


## Step 1: Gitlab

Create `.gitlab-ci.yml`:

```yaml
stages:
  - test
  - androidBuild
  - androidDeploy

variables:
  FLUTTER_VERSION: "3.35.4"

image: ghcr.io/cirruslabs/flutter:${FLUTTER_VERSION}

test:
  stage: test
  script:
    # Show current Flutter & Dart version
    - flutter --version
    - dart --version

    # Clone the correct Flutter version
    - git clone https://github.com/flutter/flutter.git --branch $FLUTTER_VERSION --depth 1
    - export PATH="$PWD/flutter/bin:$PATH"

    # Install Node.js for OpenAPI generator
    - apt-get update && apt-get install -y curl
    - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
    - apt-get install -y nodejs
    - npm install -g @openapitools/openapi-generator-cli
    
    # Generate API and get dependencies
    - dart run tool/generate_api.dart

    # Verify the new Flutter & Dart
    - flutter --version
    - dart --version

    # Install dependencies and run tests
    - flutter pub get
    - flutter test
  only:
    - /^release\/.*$/


androidBuild:
  stage: androidBuild
  before_script:
  # Decode the Base64 keystore to binary .jks file
  - echo $KEYSTORE_FILE

  - echo $KEYSTORE_FILE | base64 -d > android/app/key.jks
  
  # Verify the keystore file was created successfully
  - ls -lh android/app/key.jks
  # Create key.properties for Gradle
  - |
    cat > android/key.properties <<EOL
    storeFile=key.jks
    storePassword=$KEYSTORE_PASSWORD
    keyAlias=upload
    keyPassword=$KEY_PASSWORD
    EOL
  - cat android/key.properties

  script:
    # Show current Flutter & Dart version
    - flutter --version
    - dart --version

    # Clone the correct Flutter version
    - git clone https://github.com/flutter/flutter.git --branch $FLUTTER_VERSION --depth 1
    - export PATH="$PWD/flutter/bin:$PATH"

    # Install Node.js for OpenAPI generator
    - apt-get update && apt-get install -y curl
    - curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
    - apt-get install -y nodejs
    - npm install -g @openapitools/openapi-generator-cli
    
    # Generate API and get dependencies
    - dart run tool/generate_api.dart

    # Ensure dependencies are installed
    - flutter clean && flutter build appbundle --release


  artifacts:
    expire_in: 1 day
    paths:
      - build/app/outputs/bundle/release/app-release.aab
  only:
    - /^release\/.*$/


androidDeploy:
  stage: androidDeploy
  dependencies:
    - androidBuild
  image: ruby:3.1
  before_script:
    # Install bundler and dependencies
    - gem install bundler
    - cd android && bundle install
    - echo $SERVICE_ACCOUNT | base64 -d > service-account.json
  script:
    - bundle exec fastlane playstore_closed_test_release
  only:
    - /^release\/.*$/

```

## Step 2: Automated Testing

Set up comprehensive testing:

```dart
// test/widget_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:your_app/main.dart';

void main() {
  testWidgets('App loads successfully', (WidgetTester tester) async {
    await tester.pumpWidget(const MyApp());
    expect(find.text('Welcome'), findsOneWidget);
  });
}
```

## Step 3: Code Quality Checks

Add linting and analysis:

```yaml
- name: Analyze code
  run: flutter analyze

- name: Check formatting
  run: flutter format --set-exit-if-changed .
```

## Step 4: Build & Deploy

For Android (Google Play):

```yaml
- name: Build Android App Bundle
  run: flutter build appbundle --release

- name: Deploy to Play Store
  uses: r0adkll/upload-google-play@v1
  with:
    serviceAccountJsonPlainText: ${{ secrets.SERVICE_ACCOUNT_JSON }}
    packageName: com.yourcompany.app
    releaseFiles: build/app/outputs/bundle/release/app-release.aab
    track: production
```

For iOS (App Store):

```yaml
- name: Build iOS
  run: |
    cd ios
    pod install
    cd ..
    flutter build ios --release --no-codesign

- name: Deploy to TestFlight
  uses: apple-actions/upload-testflight-build@v1
  with:
    app-path: build/ios/ipa/app.ipa
    issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
    api-key-id: ${{ secrets.APPSTORE_API_KEY_ID }}
    api-private-key: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}
```

## Best Practices

1. **Separate environments**: dev, staging, production
2. **Automated versioning**: Use semantic versioning
3. **Security**: Store secrets in GitHub Secrets
4. **Notifications**: Add Slack/Discord webhooks
5. **Rollback strategy**: Keep previous builds accessible

## Conclusion

With this CI/CD pipeline, every push triggers automated testing and deployment, saving hours of manual work and reducing errors.

**Next Steps**: Integrate crash reporting (Firebase Crashlytics) and analytics into your pipeline.
